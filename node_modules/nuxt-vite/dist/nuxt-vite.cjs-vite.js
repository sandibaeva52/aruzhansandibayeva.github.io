'use strict';

const pathe = require('pathe');
const vite = require('vite');
const consola = require('consola');
const vitePluginVue2 = require('vite-plugin-vue2');
const PluginLegacy = require('@vitejs/plugin-legacy');
const fsExtra = require('fs-extra');
const crypto = require('crypto');
const module$1 = require('module');
const createResolver = require('postcss-import-resolver');
const defu = require('defu');

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

function _interopNamespace(e) {
  if (e && e.__esModule) return e;
  const n = Object.create(null);
  if (e) {
    for (const k in e) {
      if (k !== 'default') {
        const d = Object.getOwnPropertyDescriptor(e, k);
        Object.defineProperty(n, k, d.get ? d : {
          enumerable: true,
          get: function () { return e[k]; }
        });
      }
    }
  }
  n["default"] = e;
  return Object.freeze(n);
}

const vite__namespace = /*#__PURE__*/_interopNamespace(vite);
const consola__default = /*#__PURE__*/_interopDefaultLegacy(consola);
const PluginLegacy__default = /*#__PURE__*/_interopDefaultLegacy(PluginLegacy);
const fsExtra__default = /*#__PURE__*/_interopDefaultLegacy(fsExtra);
const createResolver__default = /*#__PURE__*/_interopDefaultLegacy(createResolver);
const defu__default = /*#__PURE__*/_interopDefaultLegacy(defu);

const needsJsxProcessing = (id = "") => !id.includes("node_modules") && [".vue", ".jsx", ".tsx"].some((extension) => id.includes(extension));
function jsxPlugin() {
  return {
    name: "nuxt:jsx",
    transform(code, id) {
      if (!needsJsxProcessing(id)) {
        return null;
      }
      return {
        code: code.replace(/render\s*\(\s*\)\s*\{/g, "render(h){"),
        map: null
      };
    }
  };
}

function replace(replacements) {
  return {
    name: "nuxt:replace",
    transform(code) {
      Object.entries(replacements).forEach(([key, value]) => {
        const escapedKey = key.replace(/\./g, "\\.");
        code = code.replace(new RegExp(escapedKey, "g"), value);
      });
      return {
        code,
        map: null
      };
    }
  };
}

async function buildClient(ctx) {
  const alias = {};
  for (const p of ctx.builder.plugins) {
    alias[p.name] = p.mode === "server" ? `defaultexport:${pathe.resolve(ctx.nuxt.options.buildDir, "empty.js")}` : `defaultexport:${p.src}`;
  }
  const clientConfig = vite__namespace.mergeConfig(ctx.config, {
    define: {
      "process.server": false,
      "process.client": true,
      "process.static": false,
      global: "window",
      "module.hot": false
    },
    cacheDir: pathe.resolve(ctx.nuxt.options.rootDir, "node_modules/.cache/vite/client"),
    resolve: {
      alias
    },
    build: {
      outDir: pathe.resolve(ctx.nuxt.options.buildDir, "dist/client"),
      assetsDir: ".",
      rollupOptions: {
        input: pathe.resolve(ctx.nuxt.options.buildDir, "client.js")
      },
      manifest: true,
      ssrManifest: true
    },
    plugins: [
      replace({ "process.env": "import.meta.env" }),
      jsxPlugin(),
      vitePluginVue2.createVuePlugin(ctx.config.vue),
      PluginLegacy__default["default"]()
    ],
    server: {
      middlewareMode: true
    }
  });
  await ctx.nuxt.callHook("vite:extendConfig", clientConfig, { isClient: true, isServer: false });
  if (!ctx.nuxt.options.dev) {
    const start = Date.now();
    consola__default["default"].info("Building client...");
    await vite__namespace.build(clientConfig);
    consola__default["default"].success(`Client built in ${Date.now() - start}ms`);
    return;
  }
  const viteServer = await vite__namespace.createServer(clientConfig);
  await ctx.nuxt.callHook("vite:serverCreated", viteServer);
  const viteMiddleware = (req, res, next) => {
    const originalURL = req.url;
    req.url = req.url.replace("/_nuxt/", "/.nuxt/");
    viteServer.middlewares.handle(req, res, (err) => {
      req.url = originalURL;
      next(err);
    });
  };
  await ctx.nuxt.callHook("server:devMiddleware", viteMiddleware);
  ctx.nuxt.hook("close", async () => {
    await viteServer.close();
  });
}

const pDebounce = (fn, wait, options = {}) => {
  if (!Number.isFinite(wait)) {
    throw new TypeError("Expected `wait` to be a finite number");
  }
  let leadingValue;
  let timeout;
  let resolveList = [];
  return function(...arguments_) {
    return new Promise((resolve) => {
      const shouldCallNow = options.before && !timeout;
      clearTimeout(timeout);
      timeout = setTimeout(() => {
        timeout = null;
        const result = options.before ? leadingValue : fn.apply(this, arguments_);
        for (resolve of resolveList) {
          resolve(result);
        }
        resolveList = [];
      }, wait);
      if (shouldCallNow) {
        leadingValue = fn.apply(this, arguments_);
        resolve(leadingValue);
      } else {
        resolveList.push(resolve);
      }
    });
  };
};
pDebounce.promise = (function_) => {
  let currentPromise;
  return async function(...arguments_) {
    if (currentPromise) {
      return currentPromise;
    }
    try {
      currentPromise = function_.apply(this, arguments_);
      return await currentPromise;
    } finally {
      currentPromise = void 0;
    }
  };
};

const wpfs = {
  ...fsExtra__default["default"],
  join: pathe.join
};

function uniq(arr) {
  return Array.from(new Set(arr));
}
const IS_JS_RE = /\.[cm]?js(\?[^.]+)?$/;
const HAS_EXT_RE = /[^./]+\.[^./]+$/;
const IS_CSS_RE = /\.css(\?[^.]+)?$/;
function isJS(file) {
  return IS_JS_RE.test(file) || !HAS_EXT_RE.test(file);
}
function isCSS(file) {
  return IS_CSS_RE.test(file);
}
function hashId(id) {
  return "$id_" + hash(id);
}
function hash(input, length = 8) {
  return crypto.createHash("sha256").update(input).digest("hex").substr(0, length);
}

const DEFAULT_APP_TEMPLATE = `
<!DOCTYPE html>
<html {{ HTML_ATTRS }}>
<head {{ HEAD_ATTRS }}>
  {{ HEAD }}
</head>
<body {{ BODY_ATTRS }}>
  {{ APP }}
</body>
</html>
`;
async function prepareManifests(ctx) {
  const rDist = (...args) => pathe.resolve(ctx.nuxt.options.buildDir, "dist", ...args);
  await fsExtra.mkdirp(rDist("server"));
  const customAppTemplateFile = pathe.resolve(ctx.nuxt.options.srcDir, "app.html");
  const APP_TEMPLATE = fsExtra.existsSync(customAppTemplateFile) ? await fsExtra.readFile(customAppTemplateFile, "utf-8") : DEFAULT_APP_TEMPLATE;
  const DEV_TEMPLATE = APP_TEMPLATE.replace("</body>", '<script type="module" src="/@vite/client"><\/script><script type="module" src="/.nuxt/client.js"><\/script></body>');
  const SPA_TEMPLATE = ctx.nuxt.options.dev ? DEV_TEMPLATE : APP_TEMPLATE;
  const SSR_TEMPLATE = ctx.nuxt.options.dev ? DEV_TEMPLATE : APP_TEMPLATE;
  await fsExtra.writeFile(rDist("server/index.ssr.html"), SSR_TEMPLATE);
  await fsExtra.writeFile(rDist("server/index.spa.html"), SPA_TEMPLATE);
  if (ctx.nuxt.options.dev) {
    await stubManifest(ctx);
  } else {
    await generateBuildManifest(ctx);
  }
}
async function generateBuildManifest(ctx) {
  const rDist = (...args) => pathe.resolve(ctx.nuxt.options.buildDir, "dist", ...args);
  const publicPath = ctx.nuxt.options.app.assetsPath;
  const viteClientManifest = await fsExtra.readJSON(rDist("client/manifest.json"));
  const clientEntries = Object.entries(viteClientManifest);
  const asyncEntries = uniq(clientEntries.filter((id) => id[1].isDynamicEntry).flatMap(getModuleIds)).filter(Boolean);
  const initialEntries = uniq(clientEntries.filter((id) => !id[1].isDynamicEntry).flatMap(getModuleIds)).filter(Boolean);
  const initialJs = initialEntries.filter(isJS);
  const initialAssets = initialEntries.filter(isCSS);
  const polyfillName = initialEntries.find((id) => id.startsWith("polyfills-legacy."));
  const clientImports = initialJs.filter((id) => id !== polyfillName).map((id) => publicPath + id);
  const clientEntryCode = `var imports = ${JSON.stringify(clientImports)}
imports.reduce((p, id) => p.then(() => System.import(id)), Promise.resolve())`;
  const clientEntryName = "entry-legacy." + hash(clientEntryCode) + ".js";
  const clientManifest = {
    publicPath,
    all: uniq([
      polyfillName,
      clientEntryName,
      ...clientEntries.flatMap(getModuleIds)
    ]).filter(Boolean),
    initial: [
      polyfillName,
      clientEntryName,
      ...initialAssets
    ],
    async: [
      ...initialJs,
      ...asyncEntries
    ],
    modules: {},
    assetsMapping: {}
  };
  const serverManifest = {
    entry: "server.js",
    files: {
      "server.js": "server.js",
      ...Object.fromEntries(clientEntries.map(([id, entry]) => [id, entry.file]))
    },
    maps: {}
  };
  await fsExtra.writeFile(rDist("client", clientEntryName), clientEntryCode, "utf-8");
  await writeClientManifest(clientManifest, ctx.nuxt.options.buildDir);
  await writeServerManifest(serverManifest, ctx.nuxt.options.buildDir);
  await fsExtra.remove(rDist("client/manifest.json"));
  await fsExtra.remove(rDist("client/ssr-manifest.json"));
}
async function stubManifest(ctx) {
  const clientManifest = {
    publicPath: "",
    all: [
      "empty.js"
    ],
    initial: [
      "empty.js"
    ],
    async: [],
    modules: {},
    assetsMapping: {}
  };
  const serverManifest = {
    entry: "server.js",
    files: {
      "server.js": "server.js"
    },
    maps: {}
  };
  await writeClientManifest(clientManifest, ctx.nuxt.options.buildDir);
  await writeServerManifest(serverManifest, ctx.nuxt.options.buildDir);
}
async function generateDevSSRManifest(ctx) {
  const rDist = (...args) => pathe.resolve(ctx.nuxt.options.buildDir, "dist", ...args);
  const ssrManifest = await fsExtra.readJSON(rDist("server/ssr-manifest.json"));
  const css = Object.keys(ssrManifest).filter(isCSS);
  const fixedCss = css.map((i) => `../${i}`);
  const clientManifest = {
    publicPath: "",
    all: [
      "empty.js",
      ...fixedCss
    ],
    initial: [
      "empty.js",
      ...fixedCss
    ],
    async: [],
    modules: {},
    assetsMapping: {}
  };
  await writeClientManifest(clientManifest, ctx.nuxt.options.buildDir);
}
async function writeServerManifest(serverManifest, buildDir) {
  const serverManifestJSON = JSON.stringify(serverManifest, null, 2);
  await fsExtra.writeFile(pathe.resolve(buildDir, "dist/server/server.manifest.json"), serverManifestJSON, "utf-8");
  await fsExtra.writeFile(pathe.resolve(buildDir, "dist/server/server.manifest.mjs"), `export default ${serverManifestJSON}`, "utf-8");
}
async function writeClientManifest(clientManifest, buildDir) {
  const clientManifestJSON = JSON.stringify(clientManifest, null, 2);
  await fsExtra.writeFile(pathe.resolve(buildDir, "dist/server/client.manifest.json"), clientManifestJSON, "utf-8");
  await fsExtra.writeFile(pathe.resolve(buildDir, "dist/server/client.manifest.mjs"), `export default ${clientManifestJSON}`, "utf-8");
}
function getModuleIds([, value]) {
  if (!value) {
    return [];
  }
  return [value.file, ...value.css || []].filter((id) => isCSS(id) || id.match(/-legacy\./));
}

async function transformRequest(viteServer, id) {
  if (id && id.startsWith("/@id/__x00__")) {
    id = "\0" + id.slice("/@id/__x00__".length);
  }
  if (id && id.startsWith("/@id/defaultexport")) {
    id = id.slice("/@id/".length);
  }
  if (module$1.builtinModules.includes(id)) {
    return {
      code: `(global, exports, importMeta, ssrImport, ssrDynamicImport, ssrExportAll) => { ssrExportAll(require('${id.replace(/^\/@fs/, "")}')) }`,
      deps: [],
      dynamicDeps: []
    };
  }
  const res = await viteServer.transformRequest(id, { ssr: true }).catch((err) => {
    console.warn(`[SSR] Error transforming ${id}: ${err}`);
  }) || { code: "", map: {}, deps: [], dynamicDeps: [] };
  const code = `async function (global, __vite_ssr_exports__, __vite_ssr_import_meta__, __vite_ssr_import__, __vite_ssr_dynamic_import__, __vite_ssr_exportAll__) {
const module = __createCJSModule__(__vite_ssr_exports__)
${res.code || "/* empty */"};
}`;
  return { code, deps: res.deps || [], dynamicDeps: res.dynamicDeps || [] };
}
async function transformRequestRecursive(viteServer, id, parent = "<entry>", chunks = {}) {
  if (chunks[id]) {
    chunks[id].parents.push(parent);
    return;
  }
  const res = await transformRequest(viteServer, id);
  const deps = uniq([...res.deps, ...res.dynamicDeps]);
  chunks[id] = {
    id,
    code: res.code,
    deps,
    parents: [parent]
  };
  for (const dep of deps) {
    await transformRequestRecursive(viteServer, dep, id, chunks);
  }
  return Object.values(chunks);
}
async function bundleRequest(viteServer, entryURL) {
  const chunks = await transformRequestRecursive(viteServer, entryURL);
  const listIds = (ids) => ids.map((id) => `// - ${id} (${hashId(id)})`).join("\n");
  const chunksCode = chunks.map((chunk) => `
// --------------------
// Request: ${chunk.id}
// Parents: 
${listIds(chunk.parents)}
// Dependencies: 
${listIds(chunk.deps)}
// --------------------
const ${hashId(chunk.id)} = ${chunk.code}
`).join("\n");
  const manifestCode = "const __modules__ = {\n" + chunks.map((chunk) => ` '${chunk.id}': ${hashId(chunk.id)}`).join(",\n") + "\n}";
  const ssrModuleLoader = `
const __pendingModules__ = new Map()
const __pendingImports__ = new Map()
const __ssrContext__ = { global: {} }

function __ssrLoadModule__(url, urlStack = []) {
  const pendingModule = __pendingModules__.get(url)
  if (pendingModule) { return pendingModule }
  const modulePromise = __instantiateModule__(url, urlStack)
  __pendingModules__.set(url, modulePromise)
  modulePromise.catch(() => { __pendingModules__.delete(url) })
         .finally(() => { __pendingModules__.delete(url) })
  return modulePromise
}

function __createCJSModule__(exports) {
  return { 
    get exports() {
      if (!exports.default)
        exports.default = {}
      return exports.default
    },
    set exports(v) {
      exports.default = v
    }
  }
}

async function __instantiateModule__(url, urlStack) {
  const mod = __modules__[url]
  if (mod.stubModule) { return mod.stubModule }
  let stubModule = { [Symbol.toStringTag]: 'Module' }
  Object.defineProperty(stubModule, '__esModule', { value: true })
  mod.stubModule = stubModule
  const importMeta = { url, hot: { accept() {} } }
  urlStack = urlStack.concat(url)
  const isCircular = url => urlStack.includes(url)
  const pendingDeps = []
  const ssrImport = async (dep) => {
    // TODO: Handle externals if dep[0] !== '.' | '/'
    if (!isCircular(dep) && !__pendingImports__.get(dep)?.some(isCircular)) {
      pendingDeps.push(dep)
      if (pendingDeps.length === 1) {
        __pendingImports__.set(url, pendingDeps)
      }
      await __ssrLoadModule__(dep, urlStack)
      if (pendingDeps.length === 1) {
        __pendingImports__.delete(url)
      } else {
        pendingDeps.splice(pendingDeps.indexOf(dep), 1)
      }
    }
    return __modules__[dep].stubModule
  }
  function ssrDynamicImport (dep) {
    // TODO: Handle dynamic import starting with . relative to url
    return ssrImport(dep)
  }

  function ssrExportAll(sourceModule) {
    for (const key in sourceModule) {
      if (key !== 'default') {
        try {
          Object.defineProperty(stubModule, key, {
            enumerable: true,
            configurable: true,
            get() { return sourceModule[key] }
          })
        } catch (_err) { }
      }
    }
  }

  await mod(
    __ssrContext__.global,
    stubModule,
    importMeta,
    ssrImport,
    ssrDynamicImport,
    ssrExportAll
  )

  // fix for cjs/esm misalignment
  if (!('default' in stubModule)) {
    stubModule.default = stubModule
  }

  return stubModule
}
`;
  const code = [
    chunksCode,
    manifestCode,
    ssrModuleLoader,
    `module.exports = function (...args) { return __ssrLoadModule__('${entryURL}').then(i => i.default(...args)) }`
  ].join("\n\n");
  return { code };
}

async function buildServer(ctx) {
  const _env = process.env.NODE_ENV;
  process.env.NODE_ENV = "production";
  const vuePlugin = vitePluginVue2.createVuePlugin(ctx.config.vue);
  process.env.NODE_ENV = _env;
  const alias = {};
  for (const p of ctx.builder.plugins) {
    alias[p.name] = p.mode === "client" ? `defaultexport:${pathe.resolve(ctx.nuxt.options.buildDir, "empty.js")}` : `defaultexport:${p.src}`;
  }
  const serverConfig = vite__namespace.mergeConfig(ctx.config, {
    define: {
      "process.server": true,
      "process.client": false,
      "process.static": false,
      "typeof window": '"undefined"',
      "typeof document": '"undefined"',
      "typeof navigator": '"undefined"',
      "typeof location": '"undefined"',
      "typeof XMLHttpRequest": '"undefined"'
    },
    cacheDir: pathe.resolve(ctx.nuxt.options.rootDir, "node_modules/.cache/vite/server"),
    resolve: {
      alias
    },
    ssr: {
      external: [
        "axios"
      ],
      noExternal: [
        ...ctx.nuxt.options.build.transpile.filter((i) => typeof i === "string")
      ]
    },
    build: {
      outDir: pathe.resolve(ctx.nuxt.options.buildDir, "dist/server"),
      assetsDir: ctx.nuxt.options.app.assetsPath.replace(/^\/|\/$/, ""),
      ssr: true,
      ssrManifest: true,
      rollupOptions: {
        input: pathe.resolve(ctx.nuxt.options.buildDir, "server.js"),
        onwarn(warning, rollupWarn) {
          if (!["UNUSED_EXTERNAL_IMPORT"].includes(warning.code)) {
            rollupWarn(warning);
          }
        }
      }
    },
    plugins: [
      jsxPlugin(),
      vuePlugin
    ]
  });
  await ctx.nuxt.callHook("vite:extendConfig", serverConfig, { isClient: false, isServer: true });
  const onBuild = () => ctx.nuxt.callHook("build:resources", wpfs);
  if (!ctx.nuxt.options.dev) {
    const start = Date.now();
    consola__default["default"].info("Building server...");
    await vite__namespace.build(serverConfig);
    await onBuild();
    consola__default["default"].success(`Server built in ${Date.now() - start}ms`);
    return;
  }
  const viteServer = await vite__namespace.createServer(serverConfig);
  ctx.nuxt.hook("close", () => viteServer.close());
  await viteServer.pluginContainer.buildStart({});
  await fsExtra.writeFile(pathe.resolve(ctx.nuxt.options.buildDir, "dist/server/ssr-manifest.json"), JSON.stringify({}, null, 2), "utf-8");
  await generateDevSSRManifest(ctx);
  const _doBuild = async () => {
    const start = Date.now();
    const { code } = await bundleRequest(viteServer, "/.nuxt/server.js");
    await fsExtra.writeFile(pathe.resolve(ctx.nuxt.options.buildDir, "dist/server/server.js"), code, "utf-8");
    const time = Date.now() - start;
    consola__default["default"].info(`Server built in ${time}ms`);
    await onBuild();
  };
  const doBuild = pDebounce(_doBuild, 300);
  await _doBuild();
  viteServer.watcher.on("all", (_event, file) => {
    if (file.indexOf(ctx.nuxt.options.buildDir) === 0) {
      return;
    }
    doBuild();
  });
}

const PREFIX = "defaultexport:";
const hasPrefix = (id = "") => id.startsWith(PREFIX);
const removePrefix = (id = "") => hasPrefix(id) ? id.substr(PREFIX.length) : id;
const hasDefaultExport = (code = "") => code.includes("export default");
const addDefaultExport = (code = "") => code + "\n\nexport default () => {}";
function defaultExportPlugin() {
  return {
    name: "nuxt:default-export",
    enforce: "pre",
    resolveId(id, importer) {
      if (hasPrefix(id)) {
        return id;
      }
      if (importer && hasPrefix(importer)) {
        return this.resolve(id, removePrefix(importer));
      }
      return null;
    },
    async load(id) {
      if (hasPrefix(id)) {
        let code = await fsExtra.readFile(removePrefix(id), "utf8");
        if (!hasDefaultExport(code)) {
          code = addDefaultExport(code);
        }
        return { map: null, code };
      }
      return null;
    }
  };
}

function resolveCSSOptions(nuxt) {
  const css = {
    postcss: {
      plugins: []
    }
  };
  const plugins = defu__default["default"](nuxt.options.build.postcss.plugins, {
    "postcss-import": {
      resolve: createResolver__default["default"]({
        alias: { ...nuxt.options.alias },
        modules: [
          nuxt.options.srcDir,
          nuxt.options.rootDir,
          ...nuxt.options.modulesDir
        ]
      })
    },
    "postcss-url": {},
    "postcss-preset-env": nuxt.options.build.postcss.preset || {}
  });
  for (const name in plugins) {
    const opts = plugins[name];
    if (!opts) {
      continue;
    }
    const plugin = nuxt.resolver.requireModule(name);
    css.postcss.plugins.push(plugin(opts));
  }
  return css;
}

async function warmupViteServer(server, entries) {
  const warmedUrls = new Set();
  const warmup = async (url) => {
    if (warmedUrls.has(url)) {
      return void 0;
    }
    warmedUrls.add(url);
    try {
      await server.transformRequest(url);
    } catch (e) {
      consola__default["default"].debug("Warmup for %s failed with: %s", url, e);
    }
    const deps = Array.from(server.moduleGraph.urlToModuleMap.get(url).importedModules);
    await Promise.all(deps.map((m) => warmup(m.url)));
  };
  await Promise.all(entries.map((entry) => warmup(entry)));
}

async function bundle(nuxt, builder) {
  for (const p of builder.plugins) {
    p.src = nuxt.resolver.resolvePath(pathe.resolve(nuxt.options.buildDir, p.src));
  }
  const ctx = {
    nuxt,
    builder,
    config: vite__namespace.mergeConfig(nuxt.options.vite || {}, {
      root: nuxt.options.rootDir,
      mode: nuxt.options.dev ? "development" : "production",
      logLevel: "warn",
      define: {
        "process.dev": nuxt.options.dev
      },
      resolve: {
        extensions: [".mjs", ".js", ".ts", ".jsx", ".tsx", ".json", ".vue"],
        alias: {
          ...nuxt.options.alias,
          ".nuxt": nuxt.options.buildDir,
          _nuxt: nuxt.options.buildDir,
          "~": nuxt.options.srcDir,
          "@": nuxt.options.srcDir,
          "web-streams-polyfill/ponyfill/es2018": require.resolve("./runtime/mock/web-streams-polyfill.mjs"),
          "whatwg-url": require.resolve("./runtime/mock/whatwg-url.mjs"),
          "abort-controller": require.resolve("./runtime/mock/abort-controller.mjs")
        }
      },
      vue: {},
      server: {
        fs: {
          strict: false
        }
      },
      css: resolveCSSOptions(nuxt),
      optimizeDeps: {
        exclude: [
          "ufo",
          "date-fns",
          "nanoid"
        ]
      },
      esbuild: {
        jsxFactory: "h",
        jsxFragment: "Fragment"
      },
      publicDir: pathe.resolve(nuxt.options.srcDir, nuxt.options.dir.static),
      clearScreen: false,
      build: {
        emptyOutDir: false
      },
      plugins: [
        replace({
          __webpack_public_path__: "globalThis.__webpack_public_path__"
        }),
        jsxPlugin(),
        defaultExportPlugin()
      ]
    })
  };
  const i18nAlias = ctx.config.resolve.alias["~i18n-klona"];
  if (i18nAlias) {
    ctx.config.resolve.alias["~i18n-klona"] = i18nAlias.replace(".js", ".mjs");
  }
  await ctx.nuxt.callHook("vite:extend", ctx);
  if (nuxt.options.dev) {
    ctx.nuxt.hook("vite:serverCreated", (server) => {
      const start = Date.now();
      warmupViteServer(server, ["/.nuxt/client.js"]).then(() => {
        consola__default["default"].info(`Vite warmed up in ${Date.now() - start}ms`);
      }).catch(consola__default["default"].error);
    });
  }
  await buildClient(ctx);
  await prepareManifests(ctx);
  await buildServer(ctx);
}
class ViteBuilder {
  constructor(builder) {
    this.builder = builder;
    this.nuxt = builder.nuxt;
  }
  build() {
    return bundle(this.nuxt, this.builder);
  }
}

exports.ViteBuilder = ViteBuilder;
